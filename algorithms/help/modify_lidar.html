<h2>License Information</h2> <p>Use of this function requires a license for Whitebox Workflows for Python Professional (WbW-Pro). Please visit <a href="https://www.whiteboxgeo.com/">www.whiteboxgeo.com</a> to purchase a license.</p> <h2>Description</h2> <p>The ModifyLidar tool can be used to alter the properties of points within a LiDAR point cloud. The user provides a statement (<code>statement</code>) containing one or more expressions, separated by semicolons (;). The expressions are evaluated for each point within the input LiDAR file (<code>input</code>). Expressions assign altered values to the properties of points in the output file (<code>output</code>), based on any mathematically defined expression that may include the various properties of individual points (e.g. coordinates, intensity, return attributes, etc) or some file-level properties (e.g. min/max coordinates). As a basic example, the following statement:</p> <p><code>x = x + 1000.0 </code> could be used to translate the point cloud 1000 x-units (note, the increment operator could be used as a simpler equivalent, <code>x += 1000.0</code>).</p> <p>Note that if the user does not specify the optional input LiDAR file, the tool will search for all valid LiDAR (<em>.las, </em>.laz, *.zlidar) files contained within the current working directory. This feature can be useful for processing a large number of LiDAR files in batch mode. When this batch mode is applied, the output file names will be the same as the input file names but with a '_modified' suffix added to the end.</p> <p>Expressions may contain any of the following point-level or file-level variables:</p> <table> <th><td>Variable Name</td><td>Description</td><td>Type</td></th> <tr><td>**Point-level properties**</td></tr> <tr><td>x</td><td>The point x coordinate</td><td>float</td></tr> <tr><td>y</td><td>The point y coordinate</td><td>float</td></tr> <tr><td>z</td><td>The point z coordinate</td><td>float</td></tr> <tr><td>xy</td><td>An x-y coordinate tuple, (x, y)</td><td>(float, float)</td></tr> <tr><td>xyz</td><td>An x-y-z coordinate tuple, (x, y, z)</td><td>(float, float, float)</td></tr> <tr><td>intensity</td><td>The point intensity value</td><td>int</td></tr> <tr><td>ret</td><td>The point return number</td><td>int</td></tr> <tr><td>nret</td><td>The point number of returns</td><td>int</td></tr> <tr><td>is_only</td><td>True if the point is an only return (i.e. ret == nret == 1), otherwise false</td><td>Boolean</td></tr> <tr><td>is_multiple</td><td>True if the point is a multiple return (i.e. nret > 1), otherwise false</td><td>Boolean</td></tr> <tr><td>is_early</td><td>True if the point is an early return (i.e. ret == 1), otherwise false</td><td>Boolean</td></tr> <tr><td>is_intermediate</td><td>True if the point is an intermediate return (i.e. ret > 1 && ret < nret), otherwise false</td><td>Boolean</td></tr> <tr><td>is_late</td><td>True if the point is a late return (i.e. ret == nret), otherwise false</td><td>Boolean</td></tr> <tr><td>is_first</td><td>True if the point is a first return (i.e. ret == 1 && nret > 1), otherwise false</td><td>Boolean</td></tr> <tr><td>is_last</td><td>True if the point is a last return (i.e. ret == nret && nret > 1), otherwise false</td><td>Boolean</td></tr> <tr><td>class</td><td>The class value in numeric form, e.g. 0 = Never classified, 1 = Unclassified, 2 = Ground, etc.</td><td>int</td></tr> <tr><td>is_noise</td><td>True if the point is classified noise (i.e. class == 7</td><td>class == 18), otherwise false</td><td>Boolean</td></tr> <tr><td>is_synthetic</td><td>True if the point is synthetic, otherwise false</td><td>Boolean</td></tr> <tr><td>is_keypoint</td><td>True if the point is a keypoint, otherwise false</td><td>Boolean</td></tr> <tr><td>is_withheld</td><td>True if the point is withheld, otherwise false</td><td>Boolean</td></tr> <tr><td>is_overlap</td><td>True if the point is an overlap point, otherwise false</td><td>Boolean</td></tr> <tr><td>scan_angle</td><td>The point scan angle</td><td>int</td></tr> <tr><td>scan_direction</td><td>True if the scanner is moving from the left towards the right, otherwise false</td><td>Boolean</td></tr> <tr><td>is_flightline_edge</td><td>True if the point is situated along the filightline edge, otherwise false</td><td>Boolean</td></tr> <tr><td>user_data</td><td>The point user data</td><td>int</td></tr> <tr><td>point_source_id</td><td>The point source ID</td><td>int</td></tr> <tr><td>scanner_channel</td><td>The point scanner channel</td><td>int</td></tr> <tr><td>time</td><td>The point GPS time, if it exists, otherwise 0</td><td>float</td></tr> <tr><td>rgb</td><td>A red-green-blue tuple (r, g, b) if it exists, otherwise (0,0,0)</td><td>(int, int, int)</td></tr> <tr><td>nir</td><td>The point near infrared value, if it exists, otherwise 0</td><td>int</td></tr> <tr><td>pt_num</td><td>The point number within the input file</td><td>int</td></tr> <tr><td>**File-level properties (invariant)**</td></tr> <tr><td>n_pts</td><td>The number of points within the file</td><td>int</td></tr> <tr><td>min_x</td><td>The file minimum x value</td><td>float</td></tr> <tr><td>mid_x</td><td>The file mid-point x value</td><td>float</td></tr> <tr><td>max_x</td><td>The file maximum x value</td><td>float</td></tr> <tr><td>min_y</td><td>The file minimum y value</td><td>float</td></tr> <tr><td>mid_y</td><td>The file mid-point y value</td><td>float</td></tr> <tr><td>max_y</td><td>The file maximum y value</td><td>float</td></tr> <tr><td>min_z</td><td>The file minimum z value</td><td>float</td></tr> <tr><td>mid_z</td><td>The file mid-point z value</td><td>float</td></tr> <tr><td>max_z</td><td>The file maximum z value</td><td>float</td></tr> <tr><td>x_scale_factor</td><td>The file x scale factor</td><td>float</td></tr> <tr><td>y_scale_factor</td><td>The file y scale factor</td><td>float</td></tr> <tr><td>z_scale_factor</td><td>The file z scale factor</td><td>float</td></tr> <tr><td>x_offset</td><td>The file x offset</td><td>float</td></tr> <tr><td>y_offset</td><td>The file y offset</td><td>float</td></tr> <tr><td>z_offset</td><td>The file z offset</td><td>float</td></tr>  </table> <p>Most of the point-level properties above are modifiable, however some are not. The complete list of modifiable point attributes include, x, y, z, xy, xyz, intensity, ret, nret, class, user_data, point_source_id, scanner_channel, scan_angle, time, rgb, nir, is_synthetic, is_keypoint, is_withheld, and is_overlap. The immutable properties include is_only, is_multiple, is_early, is_intermediate, is_late, is_first, is_last, is_noise, and pt_num. Of the file-level properties, the modifiable properties include the x_scale_factor, y_scale_factor, z_scale_factor, x_offset, y_offset, and z_offset.</p> <p>In addition to the point properties defined above, if the user applies the <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#lidar_eigenvalue_features">lidar_eigenvalue_features</a> tool on the input LiDAR file, the <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#modify_lidar">modify_lidar</a> tool will automatically read in the additional *.eigen file, which include the eigenvalue-based point neighbourhood measures, such as <code>lambda1</code>, <code>lambda2</code>, <code>lambda3</code>, <code>linearity</code>, <code>planarity</code>, <code>sphericity</code>, <code>omnivariance</code>, <code>eigentropy</code>, <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#slope">slope</a>, and <code>residual</code>. See the <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#lidar_eigenvalue_features">lidar_eigenvalue_features</a> documentation for details on each of these metrics describing the structure and distribution of points within the neighbourhood surrounding each point in the LiDAR file.</p> <p>Expressions may use any of the standard mathematical operators, +, -, *, /, % (modulo), ^ (exponentiation), comparison operators, &lt;, &gt;, &lt;=, &gt;=, == (equality), != (inequality), and logical operators, &amp;&amp; (Boolean AND),</p> <table> <th><td>(Boolean OR). Expressions must evaluate to an assignment operation, where the variable that is assigned</td></th> to must be a modifiable point-level property (see table above). That is, expressions should take the form </table> <p><code>pt_variable = ...</code>. Other assignment operators are also possible (at least for numeric non-tuple properties), such as the increment (=+) operator (e.g. <code>x += 1000.0</code>) and the decrement (-=) operator (e.g. <code>y -= 1000.0</code>). Expressions may use a number of built-in mathematical functions, including:</p> <table> <th><td>Function Name</td><td>Description</td><td>Example</td></th> <tr><td>if</td><td>Performs an if(CONDITION, TRUE, FALSE) operation, return either the value of TRUE or FALSE depending on CONDITION</td><td>`ret = if(ret==0, 1, ret)`</td></tr> <tr><td>abs</td><td>Returns the absolute value of the argument</td><td>`value = abs(x - mid_x)`</td></tr> <tr><td>min</td><td>Returns the minimum of the arguments</td><td>`value = min(x, y, z)`</td></tr> <tr><td>max</td><td>Returns the maximum of the arguments</td><td>`value = max(x, y, z)`</td></tr> <tr><td>floor</td><td>Returns the largest integer less than or equal to a number</td><td>`x = floor(x)`</td></tr> <tr><td>round</td><td>Returns the nearest integer to a number. Rounds half-way cases away from 0.0</td><td>`x = round(x)`</td></tr> <tr><td>ceil</td><td>Returns the smallest integer greater than or equal to a number</td><td>`x = ceil(x)`</td></tr> <tr><td>clamp</td><td>Forces a value to fall within a specified range, defined by a minimum and maximum</td><td>`z = clamp(min_z+10.0, z, max_z-20.0)`</td></tr> <tr><td>int</td><td>Returns the integer equivalent of a number</td><td>`intensity = int(z)`</td></tr> <tr><td>float</td><td>Returns the float equivalent of a number</td><td>`z = float(intensity)`</td></tr> <tr><td>to_radians</td><td>Converts a number in degrees to radians</td><td>`val = to_radians(scan_angle)`</td></tr> <tr><td>to_degrees</td><td>Converts a number in radians to degrees</td><td>`scan_angle = int(to_degrees(val))`</td></tr> <tr><td>dist</td><td>Returns the distance between two points defined by two n-length tuples</td><td>`d = dist(xy, (mid_x, mid_y))` or `d = dist(xyz, (mid_x, mid_y, mid_z))`</td></tr> <tr><td>rotate_pt</td><td>Rotates an x-y point by a certain angle, in degrees</td><td>`xy = rotate_pt(xy, 45.0)` or `orig_pt = (1000.0, 1000.0); xy = rotate_pt(xy, 45.0, orig_pt)`</td></tr> <tr><td>math::ln</td><td>Returns the natural logarithm of the number</td><td>`z = math::ln(z)`</td></tr> <tr><td>math::log</td><td>Returns the logarithm of the number with respect to an arbitrary base</td><td>`z = math::log(z, 10)`</td></tr> <tr><td>math::log2</td><td>Returns the base 2 logarithm of the number</td><td>`z = math::log2(z)`</td></tr> <tr><td>math::log10</td><td>Returns the base 10 logarithm of the number</td><td>`z = math::log10(z)`</td></tr> <tr><td>math::exp</td><td>Returns e^(number), (the exponential function)</td><td>`z = math::exp(z)`</td></tr> <tr><td>math::pow</td><td>Raises a number to the power of the other number</td><td>`z = math::pow(z, 2.0)`</td></tr> <tr><td>math::sqrt</td><td>Returns the square root of a number. Returns NaN for a negative number</td><td>`z = math::sqrt(z, 2.0)`</td></tr> <tr><td>math::cos</td><td>Computes the cosine of a number (in radians)</td><td>`z = math::cos(to_radians(z))`</td></tr> <tr><td>math::sin</td><td>Computes the sine of a number (in radians)</td><td>`z = math::sin(to_radians(z))`</td></tr> <tr><td>math::tan</td><td>Computes the tangent of a number (in radians)</td><td>`z = math::tan(to_radians(z))`</td></tr> <tr><td>math::acos</td><td>Computes the arccosine of a number. The return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1]</td><td>`z = math::acos(z)`</td></tr> <tr><td>math::asin</td><td>Computes the arcsine of a number. The return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1]</td><td>`z = math::asin(z)`</td></tr> <tr><td>math::atan</td><td>Computes the arctangent of a number. The return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1]</td><td>`z = math::atan(z)`</td></tr> <tr><td>rand</td><td>Returns a random value between 0 and 1, with an optional seed value</td><td>`rgb = (int(255.0 * rand()), int(255.0 * rand()), int(255.0 * rand()))`</td></tr> <tr><td>helmert_transformation</td><td>Performs a Helmert transformation on a point using a 7-parameter transform</td><td>`xyz = helmert_transformation(xyz, −446.448, 125.157, −542.06, 20.4894, −0.1502, −0.247, −0.8421 )`</td></tr>  </table> <p>The hyperbolic trigonometric functions are also available for use in expression building, as is <code>math::atan2</code> and the mathematical constants <code>pi</code> and <code>e</code>.</p> <p>You may use <code>if</code> operations within statements to implement a conditional modification of point properties. For example, the following expression demonstrates how you could modify a point's RGB colour based on its classification, assign ground points (class 2) in the output file a green colour:</p> <p><code>rgb = if(class==2, (0,255,0), rgb) </code> To colour all points within 50 m of the tile mid-point red and all other points blue:</p> <p><code>rgb = if(dist(xy, (mid_x, mid_y))&lt;50.0, (255,0,0), (0,0,255)) </code> <code>if</code> operations may also be nested to create more complex compound conditional point modification. For example, in the following statement, we assign first-return points red (255,0,0) and last-return points green (0,255,0) colours and white (255,255,255) to all other points (intermediate-returns and only-returns):</p> <p><code>rgb = if(is_first, (255,0,0), if(is_last, (0,255,0), (255,255,255))) </code> Here we use an <code>if</code> expression to re-classify points above an elevation of 1000.0 as high noise (class 18):</p> <p><code>class = if(z&gt;1000.0, 18, class) </code> Expressions may be strung together within statements using semicolons (;), with each expression being evaluated individually. When this is the case, at least one of the expressions must assign a value to one of the variant point properties (see table above). The following statement demonstrates multi-expression statements, in this case to swap the x and y coordinates in a LiDAR file:</p> <p><code>new_var = x; x = y; y = new_var </code> The <code>rand</code> function, used with the seeding option, can be useful when assigning colours to points based on common point properties. For example, to assign a point a random RGB colour based on its <code>point_source_id</code> (Note, for many point clouds, this operation will assign each flightline a unique colour; if flightline information is not stored in the file's <code>point_source_id</code> attribute, one could use the <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#recover_flightline_info">recover_flightline_info</a> tool to calculate this data.):</p> <p><code>rgb=(int(255 * rand(point_source_id)), int(255 * rand(point_source_id+1)), int(255 * rand(point_source_id+2))) </code> This expression-based approach to modifying point properties provides a great deal of flexibility and power to the processing of LiDAR point cloud data sets.</p> <h2>See Also</h2> <p><a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#filter_lidar">filter_lidar</a>, <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#sort_lidar">sort_lidar</a>, <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/tool_help.html#lidar_eigenvalue_features">lidar_eigenvalue_features</a></p>
<h2>Project Links</h2>
<div align="left">
    <a href="https://www.whiteboxgeo.com/whitebox-workflows-for-python/">WbW Homepage</a>
    <a href="https://www.whiteboxgeo.com/manual/wbw-user-manual/book/preface.html">User Manual</a>
    <a href="https://www.whiteboxgeo.com/wbw-purchase/">Support WbW</a>
</div>        
